\section{Implementation}

\subsection{Overview}
To allow for further experimentation with my findings, I will describe a prototype for an interactive web-system, built for computing student-seminar matchings. The requirements for this system were quite simple to keep it in scope of this thesis. The system constists of a website, which communicates with a server that manages the underlying data and computes the matchings. The requirements can be listed as follows:
\begin{enumerate}
    \item Allow for adding and deleting student and seminar data.
    \item Allow for computing a match using the previously entered data.
    \item Output the matching and its properties.
\end{enumerate}
This system produces matchings by using an efficient implementation of the algorithms mentioned in Section \ref{chapter:algorithms}. While the webserver itself is build in the Kotlin programm language and therefore runs on the JVM, I decided to implement the algorithms in C++ for the performance benefit I noticed when moving from a Kotlin to a C++ implementation. However, the Kotlin server is still used for generating mock testing data, gathering statistics about the results, as well as communicating with the front-end of the system.

\subsection{Algorithm Implementation}
While prototyping with a Kotlin implementation of a subset of the algorithms from Section \ref{chapter:algorithms} I noticed that performance could be significantly improved by moving to a C++ implementation of the algorithms. All of the algorithms mentioned in \mbox{Section \ref{chapter:algorithms}} were implemented. Additionally a modified version of the Max-Popular-Algorithm was implemented, which always computes a matching by exluding students matched to their last-resort seminar instead of making the whole computation fail.

\subsubsection{Input and Execution}
All five algorithms are compiled into a single binary \lstinline{seminar_assignment} using CMake. No external libraries dynamic or static libraries need to be linked. The program accepts an optional argument which specifies the algorithm to be used and then reads the problem instance on stdin. In detail, a call to the program could look like this: \lstinline{./seminar_assignment mode < instance.in} 

In this call, mode should be replaced by one of the following arguments to select an algorithm for execution: "hungarian", "popular", "popular-modified", "rsd" (default) or "max-pareto". The input format is proprietary and domain-specific and is defined as follows:
\begin{lstlisting}[frame=single, caption={Program input format},captionpos=b]
seminar_count student_count
seminar_id seminar_capacity
...
student_id pref_list_length pref_0 pref_1 .. pref_n
...
\end{lstlisting}

An example for this is the following instance with 4 students and seminars:
\lstinputlisting[frame=single, label=lst:sample-input, caption={Example instance input},captionpos=b]{assets/popular.in}

The program expects that the IDs of both students and seminars are enumerated consecutively beginning at zero, because those entities are collected into vectors, where the entities' IDs are being used as an index of the respective vector. The output of the program is written to stdout and consists of the algorithms runtime in milliseconds, followed by a newline, then the number of matched pairs, followed by a new-line and then a line for each matched pair consisting of the student-ID and space separated seminar-ID. An example of this is the following Listing \ref{lst:sample-output}, which was produced by executing the Hungarian algorithm on the instance from Listing \ref{lst:sample-input}:
\lstinputlisting[frame=single, label=lst:sample-output, caption={Output for input from Listing \ref{lst:sample-input} with the Hungarian algorithm},captionpos=b]{assets/popular.out}

The C++ program does not produce any statistics or any other side-effects. It is the responsibility of the web-server to process the matching and gather statistics. The server uses Java's Runtime API internally to create a process that executes the C++ program, by writing the problem's instance in the previously described format to the new process' stdin. The server launches each new process in a new coroutine that suspends execution until the process terminates. The resulting matching is then collected by parsing the process' stdout and creating an internal representation of it. 

\subsubsection{RSD Implementation}
This mechanism was the easiest to implement: The vector of students is first shuffled and then iterated over. Every students is directly assigned to their most-preferred, available seminar. The exact runtime lies somewhere between $\mathcal{O}(n)$ and $\mathcal{O}(n * m)$ depending on the instance, with $n$ being the number of students and $m$ the number of seminars.

\subsubsection{Max-Pareto Implementation}\label{impl:maxpo}
This algorithm makes use of the Hopcroft Karp algorithm for finding a matching. In order to use the algorithm, the vector of seminars is first expanded to take the capacities into account, by creating one new seminar for every each item of capacity. Using the vector of students and this expanded vector of seminars, a maximum cardinality is then computed. This matching is then processed, by trying to promote any student to a more-preferred seminar, if it is available, and then implementing any possible trades. For the last part, I implemented a simple graph data structure, which is used for creating a preference-graph for detecting cycles which correspond to trades. The algorithm loops until that graph is empty, i.e. all trades have been implemented. At that point the matching is pareto-optimal as described in Section \ref{algo-max-po} and is then returned. The runtime of the implementation is dominated by executing the Hopcroft-Karp algorithm and therefore yields a total of $\mathcal{O}(|E|\sqrt{n+C})$ time complexity, where $C$ is the sum of capacities of all seminars.

\subsubsection{Assignment Problem Implementation}
For the assignment problem, I used an existing open-source implementation of the \emph{Kuhn-Munkres/Hungarian} algorithm that computes a min-weight matching in $\mathcal{O}(n^3)$ time \cite{HungarianGithub}. The algorithm transforms the vectors of students and seminars into a cost matrix, which is then used by the algorithm to produce a matching. As expected, this algorithm performs the poorest in terms of runtime complexity among the other algorithms. It has to be noted that, due to the input transformation the actual runtime of the algorithm is $\mathcal{O}((n + C)^3)$, where $C$ is the sum of capacities of the seminars. This makes this algorithm less desirable for larger instances.

\subsubsection{Max-Popular Implementation}
This algorithm first assings all students whose first preference would be under-subscribed if all students are assigned to their first preference. Afterwards the Hopcroft-Karp algorithm is used again to match the unmatched students to seminars. The input is transformed the same way as in Section \ref{impl:maxpo}, however the runtime bottleneck is improved significantly due to the fact that there is only two edges per student, one for the f-house and one for the s-house. Therefore the runtime of this step is $\mathcal{O}(2n_1\sqrt{n_1+C_1})$, where $n_1$ is the number of unassigned students and $C_1$ is the total capacity left at this point. If the matching produced by the Hopcroft-Karp algorithm is not agent-complete, the algorithm returns an empty matching. Otherwise as a last step, the algorithm tries to promote students to better seminars, because the Hopcroft-Karp algorithm does not guarantee that students are matched to their more preferred seminar. In total, the runtime is again dominated by executing the Hopcroft-Karp algorithm, however due to the fact that it is operating on a reduced input, the complexity is better than in \ref{impl:maxpo}.

\subsubsection{Modified Max-Popular Implementation}\label{impl:mod-max-pop}
Due to the fact, that the Max-Popular algorithm does not always produce a matching, I implemented a modified version, which simply removes students assigned to their last-resort house, instead of making the algorithm fail. During the evaluation it will be interesting to see, if the matchings produced by this algorithm are still more popular than the ones produced by the other mechanisms.

\subsection{Web-Server Implementation}
For the implementation of the Web-Server I chose the Kotlin programming language in conjunction with the Ktor framework. Just like Java, Kotlin compiles to Java Bytecode, but provides meaningful extensions to the language such as nullable types and coroutines. Ktor is a web-server-framework that is build on top of Kotlin's coroutines to provide a declarative API for defining web-endpoints, while allowing non-blocking execution due to the coroutines' suspending nature. 
To represent the student and seminar data internally the server utilizes classes to represent students and seminars and persists them to a file by serializing the data model to JSON, whenever a value changes. Ideally, for something other than a research prototype, an alternative persistence solution, such as a database, should be used. The server provides endpoints for creating and deleting students and seminars, downloading all data in JSON-format, computing a match and finally a \emph{WebSocket} endpoint that provides real-time data-updates to the clients. When establishing a connection with the WebSocket, the app's data consisting of a list of the currently saved students and seminars is send through the WebSocket in a JSON-representation. Any updates to the app's data from any connection is then also propagated through any open WebSocket connections. This allows the clients to implement real time updates, while keeping the load of the server low by suspending the execution of each connection until data is updated. In order to compute a matching clients make a GET-request to the server's matching input, by providing the name of the algorithm in the request's path. The server then, executes the C++ program using that algorithm and the currently stored student and seminar data. The response of the endpoint is a JSON payload consisting of a map of seminars to students, the profile of the matching and the count of unassigned students.

\subsubsection{Benchmark Tools}
In addition to handling HTTP-requests, the web-server also includes infrastructure for running and evaluating experiments with the algorithms. A variety of test-data with different preference distributions can be generated and used for evaluation key metrics of the algorithms. Section \ref{sec:evaluation} will explain this in more detail. Implementation wise, the benchmark launches a coroutine for each execution of the program to allow concurrent execution. The matching data is then processed, analysed and a directory with results is being created. The result directory includes the inputs, statistics and charts visualizing the results.  

\subsection{Web-Interface Implementation}
The Front-End of the system is implemented with the Flutter framework, which is a declarative UI-framework based on Google's Dart programming language that can target the Web, Android, iOS and many desktop platforms. For the Front-End the Dart-code is transpiled into Javascript-code that draws the UI specified in the source code on a canvas in the body of the HTML page. When loading the page, the website established a WebSocket connection with the web-server to fetch the initial data and also to listen for updates. 
The website consists of three tabs: The first tab lists the students, the second tab lists the seminars and the last tab allows for computing a matching and viewing the results. Additionally the first two tabs allow for creating new student and seminar entities by filling out a simple form with the required data, as well as deleting any of those entities. Create and delete operations don't directly manipulate any data in the browser, but instead make HTTP-requests to change the data on the server, which then propagates the changes through the WebSocket connection to the website again. That way, the website treats the server as the single-source of truth for all app-data and implements real-time capabilities.