\section{Implementation}

As part of this thesis, we implement the algorithms from Section \ref{chapter:algorithms}, as well as tools for a benchmark and an interactive web system consisting of a web server and front-end. This section will give a brief overview of the implementation of those components.

\subsection{Overview}
To allow for further experimentation with our findings, we will describe a prototype for an interactive web-system, built for computing student-seminar matchings. The system consists of a website, which communicates with a server that manages the underlying data and computes the matchings. The requirements can be listed as follows:
\begin{enumerate}
    \item Allow for adding, editing and deleting student and seminar data.
    \item Allow for computing a matching using the previously entered data.
    \item Output the matching for a chosen algorithm and its properties.
\end{enumerate}
This system produces matchings by using efficient implementations of the algorithms mentioned in Section \ref{chapter:algorithms}. While the web server itself is build in the Kotlin programming language and therefore runs on the JVM, the algorithms are implemented in C++ for performance reasons. However, the Kotlin server is still used for generating mock testing data, gathering statistics about the results, as well as communicating with the front-end of the system.

\subsection{Algorithm Implementation}
All of the algorithms mentioned in \mbox{Section \ref{chapter:algorithms}} are implemented in C++. Additionally, a modified version of the Max-Popular-Algorithm is implemented, which always computes a matching by excluding students matched to their last-resort seminar, as opposed to making the whole computation fail.

\subsubsection{Input and Execution}
All five algorithms are compiled into a single binary \lstinline{seminar_assignment} using CMake. No external libraries need to be linked. The program accepts an optional argument which specifies the algorithm to be used and then reads the problem instance on stdin. In detail, a call to the program looks like this: \lstinline{./seminar_assignment mode < instance.in} 

In this call, \emph{mode} should be replaced by one of the following arguments to select an algorithm for execution: "hungarian", "popular", "popular-modified", "rsd" (default) or "max-pareto". The input format is proprietary and domain-specific and is defined as in Listing \ref{lst:input-format}.

\begin{lstlisting}[frame=single, float, label=lst:input-format, caption={Program input format},captionpos=b]
d seminar_count student_count
t seminar_id seminar_capacity
...
s student_id pref_list_length pref_0 pref_1 .. pref_n
...
\end{lstlisting}

Each line begins with a character indicating what type of information the line contains, where d represents metadata about the instance, t represents seminar data and s represents student data. An example for this is the following instance in \mbox{Listing \ref{lst:sample-input}} with 4 students and seminars:
\lstinputlisting[frame=single, label=lst:sample-input, caption={Example instance input},captionpos=b]{assets/popular.in}

The program expects that the IDs of both students and seminars are enumerated consecutively beginning at zero. The output of the program is written to stdout and consists of the algorithms runtime in milliseconds, followed by a newline, then the number of matched pairs, followed by a new-line and then a line for each matched pair consisting of the student-ID and space separated seminar-ID. An example of this is the following Listing \ref{lst:sample-output}, which was produced by executing the Hungarian algorithm on the instance from Listing \ref{lst:sample-input}:
\lstinputlisting[frame=single, label=lst:sample-output, caption={Output for input from Listing \ref{lst:sample-input} with the Hungarian algorithm},captionpos=b]{assets/popular.out}

The C++ program does not produce any statistics or any other side-effects. It is the responsibility of the web-server to process the matching and gather statistics. The server uses Java's Runtime API internally to create a process that executes the C++ program, by writing the problem's instance in the previously described format to the new process' stdin. The resulting matching is then collected by parsing the process' stdout and creating a JVM-internal representation of it. 

\subsubsection{RSD Implementation}
This mechanism is the easiest to implement: The vector of students is first shuffled and then iterated over. Every student is directly assigned to their most-preferred, available seminar.

\subsubsection{Max-Pareto Implementation}\label{impl:maxpo}
This algorithm makes use of the Hopcroft Karp algorithm for finding an initial maximum-cardinality matching. In order to use the algorithm, the vector of seminars is first expanded to take the capacities into account by creating one new seminar for every each item of capacity. Using the vector of students and this expanded vector of seminars, a maximum cardinality matching is then computed. This matching is then processed by trying to promote any student to a more-preferred seminar, if it is available, and then implementing any possible trades. For the last part, we implement a simple graph data structure, which is used for creating a preference-graph for detecting cycles which correspond to trades. The algorithm loops until that graph is empty, i.e. all trades have been implemented (maximum $n_1/2$ trades, with $n_1$ being the number of students). At that point the matching is pareto-optimal as described in Section \ref{algo-max-po} and is then returned. The runtime of the implementation is dominated by executing the Hopcroft-Karp algorithm and therefore yields a total of $\mathcal{O}(|E|\sqrt{n+C})$ time complexity, where $C$ is the sum of capacities of all seminars.

\subsubsection{Assignment Problem Implementation}
For the assignment problem, we used an existing open-source implementation of the \emph{Kuhn-Munkres/Hungarian} algorithm that computes a min-weight matching in $\mathcal{O}(n^3)$ time \cite{HungarianGithub}. Our implementation transforms the vectors of students and seminars into a cost matrix, which is then used by the Hungarian algorithm to produce a matching. As expected, this algorithm has the worst theoretical runtime complexity among the other algorithms. It has to be noted that due to the input transformation, the actual runtime of the algorithm is $\mathcal{O}((n + C)^3)$, where $C$ is the sum of capacities of the seminars. This makes this algorithm less desirable for larger instances.

\subsubsection{Max-Popular-CHA Implementation}
This algorithm first assigns all students whose first preference would be under-subscribed if all students are assigned to their first preference. Afterwards, the Hopcroft-Karp algorithm is used again to match the unmatched students to seminars. The input is transformed the same way as in Section \ref{impl:maxpo}; however, the runtime bottleneck is improved significantly due to the fact that there are only two edges per student, one for the f-house and one for the s-house. Therefore, the runtime of this step is $\mathcal{O}(2n_1\sqrt{n_1+C_1})$, where $n_1$ is the number of unassigned students and $C_1$ is the total capacity left at this point. If the matching produced by the Hopcroft-Karp algorithm leaves students unmatched, the algorithm returns an empty matching. Otherwise, as a last step, the algorithm tries to promote students to better seminars, because the Hopcroft-Karp algorithm does not guarantee that students are matched to their most preferred seminar. In total, the runtime is again dominated by executing the Hopcroft-Karp algorithm, however, because it is operating on a reduced input, the actual runtime is expected to be better than in \ref{impl:maxpo}.

\subsubsection{Modified Max-Popular-CHA Implementation}\label{impl:mod-max-pop}
Due to the fact that the Max-Popular-CHA algorithm does not always produce a matching, we implement a modified version, which simply removes students assigned to their last-resort house, instead of making the algorithm fail. During the evaluation, it is interesting to see if the matchings produced by this algorithm are still more popular than the ones produced by the other mechanisms.

\subsection{Web Server Implementation}
For the implementation of the web server we choose the Kotlin programming language in conjunction with the Ktor framework. Just like Java, Kotlin compiles to Java Bytecode, but provides meaningful extensions to the language such as nullable types and coroutines. Ktor is a web-server-framework that is built on top of Kotlin's coroutines to provide a declarative API for defining web-endpoints, while allowing non-blocking execution due to the coroutines' suspending nature. 
To represent the student and seminar data internally, the server utilizes classes to represent students and seminars and persists them to a file by serializing the data model to JSON, whenever a value changes. Ideally, for something other than a research prototype, an alternative persistence solution, such as a database, should be used. The server provides endpoints for creating, updating and deleting students and seminars, downloading all data in JSON-format, uploading a dataset, computing a matching and finally a \emph{WebSocket} endpoint that provides real-time data-updates to the clients. When establishing a connection with the WebSocket, the app's data consisting of a list of the currently saved students and seminars is sent through the WebSocket in a JSON-representation. Any updates to the app's data from any connection are then also propagated through any open WebSocket connections. This allows the clients to implement real time updates while keeping the load of the server low by suspending the execution of each connection until data is updated. In order to compute a matching, clients make a GET-request to the server's matching endpoint by providing the name of the algorithm in the request's path. The server then executes the C++ program using that algorithm and the currently stored student and seminar data. The response of the endpoint is a JSON payload consisting of a map of seminars to students, the profile of the matching and the count of unassigned students.

\subsubsection{Benchmark Tools}
In addition to handling HTTP-requests, the web-server also includes infrastructure for running and evaluating experiments with the algorithms. A variety of test-data with different preference distributions can be generated and used for evaluating key metrics of the produced matchings. The matching data is then processed, analysed and a directory with results is being created. The result directory includes the inputs, statistics and charts visualizing the results. Section \ref{sec:evaluation} explains this in more detail.

\subsection{Web-Interface Implementation}
The front end of the system is implemented with the Flutter framework, which is a declarative UI-framework based on Google's Dart programming language that can target the Web, Android, iOS and many desktop platforms. For the front end the Dart code is transpiled into JavaScript code that draws the UI specified in the source code on a canvas in the body of the HTML page. When loading the page, the website establishes a WebSocket connection with the web server to fetch the initial data and listen for updates. 
The website consists of a navigation drawer that provides access to the following tabs: the first tab lists the students, the second tab lists the seminars and the last tab allows for computing a matching and viewing the results. Additionally the first two tabs allow for creating and updating student and seminar entities by filling out a simple form with the required data, as well as deleting any of those entities. Create, update and delete operations don't directly manipulate any data in the browser, but instead make HTTP-requests to change the data on the server, which then propagates the changes through the WebSocket connection to the website again. That way, the website treats the server as the single-source of truth for all app-data and is also always up to date on changes that other users could be making. Additionally, the website offers the capability to download the currently used data as a JSON-file, as well as changing the dataset using one of the data generators used in Section \ref{sec:evaluation} or by uploading a JSON-file.

\subsection{Accessing the system and source code}
A live version of the web system is hosted at \url{https://aaronoe.github.io}. Additionally, the source code for all components can be found in the following GitHub repository: \url{https://github.com/aaronoe/matching_thesis}. Detailed instructions on building from source are included in the repositories' README file, as well as shell scripts for running the components.