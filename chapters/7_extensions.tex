\section{Extensions to the problem}
For the bulk of this thesis, we have looked at many-to-one matching problems with one-sided preferences, as this settings makes the most sense for the student-seminar application. However, there is a wide range of similar problems and extensions that are also worth mentioning. This section will present some of those problems and key results from the literature. 

\subsection{Two-Sided preferences}


\subsection{Many-to-Many matchings}

\subsection{Online variant}
When solving the online-variant of the problem, the whole input is not available from the start. That means that the input needs to be processed piece by piece, or more formally: Given a bipartite weighted graph $(U, V, E)$, where $U$ is known to the algorithm, vertices in $V$ are unknown, but arrive one at a time, while also revealing their incident edges, find a matching that maximizes some objective function. These algorithms could be of interest in the case of a first-come first-serve course allocation system, or in other areas such as DVD-rental or online-advertisement allocation systems.\cite{Mehta:Online}

In the case of student-seminar assignments, we would assume that the set of courses and their capacities is known beforehand, and the students arrive later. One of the algorithms we have seen in section \ref{chapter:algorithms} can be used for this problem, namely the RSD-algorithm. As a matter of fact, the algorithm will produce the same results for the offline and online case, given that the order in which students are processed is identical.

\subsubsection{Online max-cardinality matching}
There has been lots of research in particular on finding maximum-cardinality matchings with online inputs. The online-inputs are classified by how much information the algorithm possesses about the input order. For now, we will only consider the \textbf{Adversarial order}, where we assume no knowledge of the query sequence, which means that only $U$ is known at the beginning of the algorithm, while we have no knowledge of $V$ and $E$ or the order they appear in.\cite{Mehta:Online} To measure performance we will use the \textbf{competetive ratio} of an algorithm which is defined as follows. Given an instance of the problem $I$, the value of the objective function for the online algorithm is given as $ALG(I)$, and the value of the objective function for the best offline algorithm is given as $OPT(I)$. The competetive ratio is now computed as follows: $C.R.=\frac{ALG(I)}{OPT(I)}$.\cite{Mehta:Online}

Simple algorithms for this online problem, are a greedy algorithm, that matches arriving vertices to any available neighbor, or a random approach that matches arriving vertices to a random neighbor. These mechanisms achieve a competetive ratio of $\frac{1}{2}$.\cite{Mehta:Online} An optimal, but yet simple algorithm was introduced by Karp et al.\cite{Karp:Online}, which achieves a competetive ratio of $1 - \frac{1}{e} \simeq 0.63$. The algorithm, called Ranking, begins by permutating the known vertices of $U$ in a random permutation $\pi$, i.e. we assign a random priority number to each $u \in U$. Each incoming vertex $v \in V$ is then assigned to an available neighbor, with the smallest value of $\pi(u)$. In detail the algorithm looks like this:

\begin{algorithm} % enter the algorithm environment
    \caption{Ranking} 
    \label{alg:ranking} % and a label for \ref{} commands later in the document
    \begin{algorithmic} % enter the algorithmic environment
        \State \textbf{Offline:} Pick a random, uniform permutation $\pi$ of U
        \ForEach {arriving vertex $v \in V $}
            \If{$v$ has no available neighbors}
                \State continue
            \EndIf
            \State Match $v$ to the neighbor $u \in U$ with the smallest value $\pi(u)$
        \EndFor
    \end{algorithmic}
\end{algorithm}