\section{Discussion}

The goal of this chapter is to provide an overview of both the theoretical and practical results and to give detailed comparisons and a trade-off analysis of the algorithms.

\subsection{Discussion of Theoretical and Practical Results}
Drawing back to the theoretical results from Table \ref{tab:algorithm-comparison}, we have already seen that none of the algorithms produce matchings will all of the desired criteria. In particular, strategy-proofness cannot be achieved if trying to maximize a matching's cardinality. Popular-CHA, which theoretically is strategy-proof, unfortunately does not always find a matching, which makes it less suitable for real-world applications. Both the results from Diebold et al. (Section \ref{sec:practical-results-lit}) and our experiment show that Popular-CHA fails for about 90\% of the tested instances. There is also no known algorithm that efficiently computes the popular matching if it is not of maximum cardinality, which makes it questionable as to whether or not popularity should be considered when designing such a matching system. The results from Table \ref{tab:results-preflib2} and \ref{tab:results-uniform-large-complete} show that the matchings produced by Popular-CHA and the Hungarian algorithm often tie in terms of popularity, even though the Hungarian algorithm clearly performs better on other metrics. Looking at the rank distributions of some matchings in Figure \ref{fig:preflib2-rank-distribution} and \ref{fig:zipfian-distribution}, we have seen that (Mod-) Popular-CHA attempts to maximize the number of students assigned to their first choice in order to find a popular matching. It is highly questionable if this property is desirable over having a matching with a lower rank average, and especially a lower rank standard deviation, which is what the Hungarian algorithm typically finds. For this reason, we would argue that popularity as an optimality criterion should not be of high importance when selecting a matching mechanism for the CHA problem. The results have shown that popular matchings, compared to profile-based optimal matchings, do not explicitly attempt to provide a good match for every student, but instead give some students a bad or no match in order to give the majority of students a better match.

Another surprising finding from our experiments is that Max-PaCHA usually performs worse than all other algorithms on the rank metrics, including RSD. This can easily be explained by the fact that Max-PaCHA essentially performs a local search from an initial (maximum-cardinality) matching and terminates when finding one and only one local optima. Contrary to that, the greedy approach (RSD) also performs a local search; however, it achieves better average ranks due to the fact that it does not attempt to maximize the matching's cardinality. Comparing RSD and Max-PaCHA to the other algorithms, the Hungarian algorithm and Mod-Popular-CHA should be preferred due to the fact that they simply perform better on almost all other metrics in the experiments. However, if using a strategy-proof mechanism is a requirement, RSD should obviously be used.

\subsection{Potential Algorithmic Improvements}\label{sec:improvements}
In Section \ref{impl:mod-max-pop}, we briefly discussed a modified version of the Popular-CHA algorithm that was used in the experiment to gain insights on failing instances of Popular-CHA. However, the modified algorithm leaves some room for optimization, as it does not attempt to match students that were either unmatched or assigned to their last-resort preference after performing the maximum cardinality matching. A simple way of improving this algorithm is to use one of the other algorithms (e.g. RSD) on that unmatched subset of students. Doing this would not worsen the matching's popularity, because being matched to any seminar is better than not being matched at all from a popularity perspective. Using this modified mechanism could be a good alternative to using the Hungarian algorithm when using large instances where runtime could be a problem. 

Besides that, different algorithmic approaches could be used for computing a profile-based optimal matching. In Section \ref{algo:assignment}, we presented the approach of reducing the matching problem to the assignment problem or by using flow-networks to find a rank-maximal matching. For the use case of student and seminar matchings, it can be assumed that instances will be relatively small; however, the experiments have also shown that the Hungarian algorithm's runtime is quite poor compared to the other algorithms when using larger instances. For instance, when using about 5000 students (Table \ref{tab:results-uniform-large} and \ref{tab:results-uniform-large-complete}),
the Hungarian algorithm took, on average, about 60 seconds to find a matching, compared to about 230ms for the Popular-CHA mechanism. A faster algorithm for finding a profile-based optimal matching, Rank-Max, is presented by Sng et al. \cite{SngThesis}. They show that for a given instance $I$ of the CHAT (with ties) problem, the algorithm finds a rank-maximal matching in $\mathcal{O}(\min(z^*\sqrt{C}, C + z^*)m)$, where $z^*$ is the maximal rank of an edge in an optimal solution of $I$, $C$ is the total capacity of the houses in $I$ and $m$ is the sum of the lengths of all preference lists in $I$. Compared to that, the version of the Hungarian algorithm used for the experiments has a runtime of $\mathcal{O}((C+n_1)^3)$ with $n_1$ being the number of students and $C$ again being the total capacity of all seminars. While the theoretical runtime of Rank-Max is much better than of the Hungarian algorithm, we have seen that for small, real-world instances like the PrefLib datasets (Table \ref{tab:results-preflib1}), the runtime of the Hungarian algorithm is still below 20ms.

\subsection{System Design Recommendations}
As alluded to in the previous two subsections, the Hungarian algorithm provides the best results and, from a distribution perspective, probably the fairest distribution out of all algorithms. Important properties of the algorithm are that it finds matchings of maximal cardinality, as well as matchings with the lowest average rank combined with a low rank standard deviation. While the runtime of that algorithm was the highest among all other algorithms presented, performance should not be a problem for real-world student-seminar matching scenarios, where the instances are somewhat small. To improve performance, the Max-Rank algorithm \cite{SngThesis} could be used for finding an exact result or, for very large instances, the Mod-Popular-CHA algorithm can be used. To improve the performance of all algorithms, it would also help to require students to supply at least $k$ preferences, where $k$ could be a fixed fraction of the total seminar count. The experiments have indicated that longer preference lists, especially when power-law-like preference distributions are used, make the algorithms perform better.

Besides that, the online variant of the problem can be solved using a first-come first-serve mechanism, like RSD, or an algorithm like Ranking (Algorithm \ref{alg:ranking}) that maximizes cardinality in the online scenario (See Appendix \ref{sec:online-variants} for more information on the online problem).