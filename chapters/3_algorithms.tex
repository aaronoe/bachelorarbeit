\section{Algorithmic approaches}
In the previous section, we have discussed several optimality criteria that apply to the problem of matching students to seminars. This chapter will present algorithms for computing matchings that fulfill some of those criteria, as well as evaluating them against each other. The goal of this evaluation is choosing the "ideal" algorithm for implementation. We will see that each of the algorithms has some draw-backs, which might make them undesirable for the student-seminar problem. 

\subsection{Greedy with serial dictatorship}
One of the simplest algorithms for the student-seminar matching problem is a greedy approach, that iterates over the set of students and assigns each of the students to their most preferred seminar that still has some capacity left. In contrast to Gale \& Shapley's deferred acceptance algorithm for the stable marriage problem, this algorithm does not tentatively match students once they make their selection, but makes a final assignment. Due to that this algorithm finds a matching in $\mathcal{O}(n)$ time with $n$ being the number of students. This mechanism of letting students successively pick their highest available preference in order is known as serial dictatorship.\cite{MANEA2007316} In detail the algorithm looks like this: 

\begin{algorithm} % enter the algorithm environment
    \caption{Greedy serial dictatorship matching} 
    \label{alg1} % and a label for \ref{} commands later in the document
    \begin{algorithmic} % enter the algorithmic environment
        \Require set of Students with preferences $S$, set of Seminars $T$
        \State $M = \emptyset$
        \ForEach {$s \in \mathcal S $}
            \State $t \Leftarrow$ highest ranked, available seminar on s's preference list
            \If{$t \neq null$}
                \State $M = M \cup (s, t)$
            \EndIf
        \EndFor
        \State\Return M
    \end{algorithmic}
\end{algorithm}

Even though this algorithm is very simple and fast, it has some desirable properties including one of the optimality criteria defined before:

\subsubsection{Properties of the computed matching}
Since the order, in which the students get to pick their match is pre-defined, we can easily show that the algorithm always produces a pareto-optimal matching.
\newtheorem{theorem}{Theorem}
\begin{theorem}
    A greedy algorithm that uses serial dictatorship always produces a pareto-optimal matching.
\end{theorem}
\begin{proof}
    Let $M$ be the matching produced by the algorithm. We assume that there exists a matching $N$ that pareto-dominates $M$. Now let $s\in S$ be the first student who prefers his match in $N$ over $M$. Since $s$ prefers $N(s)$ over $M(s)$, the seminar $N(s)$ must have been unavailable when he made his pick. That means that another student $s' \in S$ exists, who picked $N(s)$ before $s$ could. However, we required that $s$ was matched to a better seminar in $N$, which means that $s'$ gets a worse match in $N$. This is a contradiction, so $N$ cannot pareto-dominate $M$.
\end{proof} TODO: citation

Another important property, that the algorithm posesses is that it is strategy-proof. This means that no student has an incentive to lie about his true preference in order to receive a better match. That holds true because the first student who gets matched, can pick his preferred, remaining seminar, the second student can pick his preferred, remaining seminar and so on.

\subsubsection{Drawbacks}
When looking at the algorithm it is clear that it has a strict preference order over students, specified by the order in which students are matched in the for loop. Additionally, the algorithm makes no effort to match all students. If it's a student's turn to pick his match, and none of the seminar's on his preference lists are free, that student will not be matched at all. This problem gets worse, when we consider that our problem statement allows for incomplete preference lists, which increases the chances of having a high number of unmatched students.
\newline
To address the first problem, a simple approach is using the random serial dictatorship mechanism, which instead creates a random order of students as the pick order. This approach is still not fair in the sense, that the first student in that order has a better chance at receiving his top priority seminar, than all other students, however, any student has the chance to be the first one to make a pick. 

\subsection{Pareto Optimal Maximal Matchings for CHA}

\subsection{Assignment Problem}

\subsection{Transformation as an instance of min-weight matching}
In order to find a rank-maximal Matching, it makes sense that a matching with the minimum weight, also satisfied the rank-maximality property. Since the problem of matching students to seminars can simply be described as finding a matching on a bipartite graph, we can simply construct such a graph and apply graph-algorithms that find such matchings for us. 
\newline
Indeed, we can simply transform the student-seminar matching problem into an instance of the minimum-cost flow problem. The goal of this algorithm will be to send $|S|$ units of flow through the network, while minimizing the cost of the flow, which is indicated by a seminar's rank on the student's preference lists:

\subsubsection{Transforming the instance}
The problem is given as a bipartite graph $G=(V=(S, T), E)$, where $S$ is the set of students and $T$ the set of seminars. The set of edges $E$ is defined as follows: $E:= \{(s, t) \mid s \in S \land t \in T \land \mbox{t is on the prefernce list of s}\}$. Additionally, a weight function $W: E \rightarrow  \mathbb{N}$ is specified, which maps each edge to the position of the seminar on the student's preference list. 

\subsection{Popular Matchings in CHA}